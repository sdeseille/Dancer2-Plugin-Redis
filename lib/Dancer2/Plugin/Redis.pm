package Dancer2::Plugin::Redis;
use strictures 1;
# ABSTRACT: Perl Dancer2 plugin for interaction with key-value-store Redis.
# COPYRIGHT

BEGIN {
  # VERSION: generated by DZP::OurPkgVersion
}

use Carp qw( carp croak );
use Types::Standard qw( Maybe Undef InstanceOf );
use Dancer2::Plugin 0.200000;
use Redis;
use Safe::Isa;
use Try::Tiny;
use Type::Tiny;

=head1 SYNOPSIS

In your I<config.yml>:

    plugins:
      Redis:
        # if you use TCP/IP:
        server: "localhost:6379"
        # if you use UNIX/Linux sockets:
        sock: "/path/to/sock"
        # (optional) Redis password used with auth:
        password: "Very secure password 123!"
        # (optional) Reconnect up to 60 seconds (reconnect) every 5000 milliseconds (every):
        reconnect: 60
        every: 5000
        # (optional) Redis connection name (NOT the Redis database ID):
        name: "my_connection_name"
        # (optional) Function called on Redis connect:
        on_connect: "MyDancer2App::redis_on_connect"
        # (optional) Use serialization for storing values other than simple scalars with Redis:
        serialization:
          # Use Sereal as serialization module:
          module: "Dancer2::Plugin::Redis::Serialization::Sereal"
          # Serialization module configuration:
          # Use snappy compression
          compression: "snappy"

In your source files:

    package MyDancer2App;
    use Dancer2;
    use Dancer2::Plugin::Redis;

    # Outputs the counter value stored in Redis, increments and saves it back to Redis.
    get '/' => sub {
      my $counter = redis_get('counter');  # Get the counter value from Redis.
      redis_set( ++$counter );             # Increment counter value by 1 and save it back to Redis.
      return $counter;
    };

    # (optional) Function called on Redis connect.
    sub redis_on_connect {
      my ( $redis ) = @_;

      # do some stuff with the bare Redis interface. This is NOT Dancer2::Plugin::Redis!

      return;
    }

=cut

############################################################################

my $TYPE_SERIALIZATIONOBJECT = Type::Tiny->new(
  name       => 'SerializationObject',
  constraint => sub { $_->$_call_if_object( 'does' => 'Dancer2::Plugin::Redis::SerializationRole' ) },
  message => sub { qq{$_ does not consume a SerializationRole} },
);

has _serialization => (
  is      => 'lazy',
  isa     => Maybe [ $TYPE_SERIALIZATIONOBJECT ],
);

sub _build__serialization {
    my ($dsl1) = @_;
    my $conf = $dsl1->config;
    my $serialization;

    # Setup serialization.
    if ( my $serialization_module = delete $conf->{serialization}{module} ) {
      $serialization_module =~ s/^/Dancer2::Plugin::Redis::Serialization::/
        if $serialization_module !~ m/^Dancer2::Plugin::Redis::Serialization::/;
      croak qq{Invalid serialization module: $serialization_module}
        if $serialization_module !~ m/^Dancer2::Plugin::Redis::Serialization::[a-zA-Z][a-zA-Z0-9_]*$/;
      try {
        eval "require $serialization_module" or croak $@;
        $serialization = "$serialization_module"->new( %{ $conf->{serialization} } );
      }
      catch {
        $dsl1->error(qq{Unable to set up serialization '$serialization_module': $_});
      };
    }
    return $serialization;
};

has _redis => (
  is      => 'lazy',
  isa     => InstanceOf ['Redis'] | InstanceOf ['t::TestApp::RedisMock'],
);

sub _build__redis {
    my ($dsl2) = @_;
    my $conf = $dsl2->config;

    if ( $conf->{test_mock} ) {
      require t::TestApp::RedisMock;
      return t::TestApp::RedisMock->new;
    }

    my %opts;

    # Build Redis->new settings.
    for (qw( server sock password reconnect every name debug )) {
      $opts{$_} = $conf->{$_} if exists $conf->{$_};
    }

    # Cleanup settings.
    delete $opts{server} if $opts{sock};   # prefer UNIX/Linux sockets.
    delete $opts{sock}   if $opts{server};
    delete $opts{password} if exists $opts{password} && ( !defined $opts{password} || $opts{password} eq '' );
    delete $opts{name} unless $opts{name};

    # Validate reconnect settings.
    if ( ( exists $opts{reconnect} || exists $opts{every} ) && ( !$opts{reconnect} || !$opts{every} ) ) {
      $dsl2->error(q{Incomplete Redis configuration for 'reconnect' and 'every', skipping...});
      delete $opts{reconnect};
      delete $opts{every};
    }

    # Validate on_connect settings.
    if ( exists $conf->{on_connect} ) {
      if ( !exists &{ $conf->{on_connect} } ) {
        $dsl2->error(q{Invalid Redis configuration for 'on_connect', skipping...});
      }
      else {
        $opts{on_connect} = \&{ $conf->{on_connect} };
      }
    }

    # Validate connection settings.
    $dsl2->error(q{Incomplete Redis configuration: required is either 'server' or 'sock'})
      if !$opts{server} && !$opts{sock};

    return Redis->new(%opts);
}

has _redis_cnx => (
    is      => 'lazy',
    isa     => InstanceOf ['Redis'] | InstanceOf ['t::TestApp::RedisMock'],
);

sub _build__redis_cnx {
    my ($dsl3, $named_cnx) = @_;
    my $conf = $dsl3->config->{connections}{$named_cnx};

    if ( $conf->{test_mock} ) {
      require t::TestApp::RedisMock;
      return t::TestApp::RedisMock->new;
    }

    my %opts;

    # Build Redis->new settings.
    for (qw( server sock password reconnect every name debug )) {
      $opts{$_} = $conf->{$_} if exists $conf->{$_};
    }

    # Cleanup settings.
    delete $opts{server} if $opts{sock};   # prefer UNIX/Linux sockets.
    delete $opts{sock}   if $opts{server};
    delete $opts{password} if exists $opts{password} && ( !defined $opts{password} || $opts{password} eq '' );
    delete $opts{name} unless $opts{name};

    # Validate reconnect settings.
    if ( ( exists $opts{reconnect} || exists $opts{every} ) && ( !$opts{reconnect} || !$opts{every} ) ) {
      $dsl3->error(q{Incomplete Redis configuration for 'reconnect' and 'every', skipping...});
      delete $opts{reconnect};
      delete $opts{every};
    }

    # Validate on_connect settings.
    if ( exists $conf->{on_connect} ) {
      if ( !exists &{ $conf->{on_connect} } ) {
        $dsl3->error(q{Invalid Redis configuration for 'on_connect', skipping...});
      }
      else {
        $opts{on_connect} = \&{ $conf->{on_connect} };
      }
    }

    # Validate connection settings.
    $dsl3->error(q{Incomplete Redis configuration: required is either 'server' or 'sock'})
      if !$opts{server} && !$opts{sock};

    return Redis->new(%opts);
}

############################################################################

sub _cnx {
  shift->redis_cnx(@_);
}

sub redis_cnx {
  my ( $dsl, $connection ) = @_;
  croak q{Connection name is required} unless $connection;
  return $dsl->_redis_cnx($connection);
}

############################################################################


############################################################################

sub _plugin {
  shift->redis_plugin;
}

sub redis_plugin {
  my ($dsl) = @_;
  return $dsl;
}

############################################################################

sub _get {
  shift->redis_get(@_);
}

sub redis_get {
  my ( $dsl, $key ) = @_;
  croak q{Redis key is required} unless $key;
  my $data = $dsl->_redis->get($key);
  if ( my $serialization = $dsl->_serialization ) {
    $data = $serialization->decode($data);
  }
  return $data;
}

############################################################################

sub _mget {
  shift->redis_mget(@_);
}

sub redis_mget {
  my ( $dsl, @keys ) = @_;
  croak q{Redis key is required} unless scalar @keys;
  my @data = $dsl->_redis->mget(@keys);
  if ( my $serialization = $dsl->_serialization ) {
    $data[$_] = $serialization->decode( $data[$_] ) for ( 0 .. scalar @data );
  }
  return @data;
}

############################################################################

sub _set {
  shift->redis_set(@_);
}

sub redis_set {
  my ( $dsl, $key, $data ) = @_;
  croak q{Redis key is required} unless $key;
  if ( my $serialization = $dsl->_serialization ) {
    $data = $serialization->encode($data);
  }
  return $dsl->_redis->set( $key => $data );
}

############################################################################

sub _mset {
  shift->redis_mset(@_);
}

sub redis_mset {
  my ( $dsl, %key_data ) = @_;
  croak q{Redis key is required} unless scalar %key_data;
  if ( my $serialization = $dsl->_serialization ) {
    $key_data{$_} = $serialization->encode( $key_data{$_} ) for ( keys %key_data );
  }
  return $dsl->_redis->mset(%key_data);
}

############################################################################

sub _expire {
  shift->redis_expire(@_);
}

sub redis_expire {
  my ( $dsl, $key, $timeout ) = @_;
  croak q{Redis key is required} unless $key;
  return $dsl->_redis->persist($key) unless $timeout;
  return $dsl->_redis->expire( $key => $timeout );
}

############################################################################

sub _del {
  shift->redis_del(@_);
}

sub redis_del {
  my ( $dsl, $key ) = @_;
  croak q{Redis key is required} unless $key;
  return $dsl->_redis->del($key);
}

############################################################################

plugin_keywords 'redis_plugin', 'redis_get', 'redis_mget', 'redis_set',
  'redis_mset', 'redis_expire', 'redis_del', 'redis_cnx';

=method redis_plugin

Returns a Dancer2::Plugin::Redis instance. You can use redis_plugin to pass the
plugin instance to 3rd party modules (backend api) so you can access the existing
Redis connection there. You will need to access the actual methods of the the plugin
instance.

    my $business_logic = Business::Logic->new( redis_plugin => redis_plugin() );

    # somewhere else ...
    package Business::Logic;

    sub frobnicate {
      return $self->redis_plugin->_get( 'key' );
    }

=method redis_get

Returns the actual value stored in Redis of a single key.

=method redis_mget

Returns the values stored in Redis for one or more keys.

=method redis_set

Assign a new value to a singe key in Redis.

=method redis_mset

Assign one or more new values to keys in Redis.

=method redis_expire

Assign a new expiration timeout to a singe key in Redis. C<undef> or a
false value will turn off expiration.

    redis_expire 'key', 10; # will expire in ten seconds

    redis_expire 'key', undef; # removes expire from key
    redis_expire 'key';        # so will this

=method redis_del

Deletes a key within Redis.

=cut

############################################################################

=head1 DESCRIPTION

This L<Perl Dancer2|Dancer2> plugin adds various Domain-specific language
(I<dsl>) symbols to interact with Redis server configured in I<config.yml>.

It uses the L<Redis> module to communicate internally with the
Redis server. It also provides serialization features to store values which
are more than just simple scalars (I<strings>). By default there is no
serialization used.

I wrote this with my colleague to cover the use cases we're having with our
own Dancer2 application. If you need additional functionality that is not included,
please don't hesitate and create a pull request on GitHub or just file your
feature request with the GitHub issue tracker.

=head2 SEREAL

In order to use the supplied
L<Sereal broker|Dancer2::Plugin::Redis::Serialization::Sereal> you have to
install L<Sereal::Decoder> and L<Sereal::Encoder>. Both modules listed as
runtime recommends with Dancer2::Plugin::Redis.

=head1 SEE ALSO

=over

=item L<Dancer2>

=item L<Redis>

=item L<Sereal>

=back

=head2 CONTRIBUTORS

The following people have contributed to Dancer2::Plugin::Redis. Thanks!

=over

=item SysPete

=back

=cut

1;
